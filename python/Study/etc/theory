[09] 빈출 기타 알고리즘
1. 소수 판별 알고리즘
    (1) 소수
        - 소수란 1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수
            - 2, 3, 5, 7 ..
        '''
        def is_prime_number(x):
            # 2부터 (x - 1)까지의 모든 수를 확인
            for i in range(2, x):
                # x가 해당 수로 나누어 떨어진다면
                if x % i == 0:
                    return False
            return True
        ''' --> 시간 복잡도 : O(X)

    (2) 약수의 성질
        - 모든 약수가 가운데 약수를 기준으로 곱셈 연산에 대해 대칭을 이룸
            ex) 16의 약수 1,2,3,8,16 -> 2 * 8 == 1 * 16
        -> 특정한 자연수의 모든 약수를 찾을 때 가운데 약수(제곱근)까지만 확인
        ''' 개선
        def is_prime_number(x):
            # 2부터 x의 제곱근까지의 모든 수 확인
            for i in range(2, int(math.sqrt(x)) + 1):
                # x가 해당 수로 나누어 떨어진다면
                if x % i == 0:
                    return False
            return True
        ''' --> 시간 복잡도 : O(N^1/2)

    (3) 에라토스테네스의 체 알고리즘
        - 특정한 수의 범위 안에 존재하는 모든 소수 찾기
        - N보다 작거나 같은 모든 소수를 찾을 때 사용
        - 과정
            1. 2부터 N까지의 모든 자연수를 나열
            2. 남은 수 중에서 아직 처리하지 않으 가장 작은 수 i를 찾는다
            3. 남은 수 중에서 i의 배수를 모두 제거(i는 제거하지 않음)
            4. 반복할 수 없을 때까지 2-3번 반복
        - 시간 복잡도 : O(NloglogN)
            - 사실상 선형 시간에 가까울 정도로 빠름
            - 단, 메모리가 많이 필요함
                ex) 10억이 소수인지 아닌지? - 메모리 측면에서 매우 비효율적

2. 투 포인터
    - 리스트에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하면서 처리
        ex) 2,3,4,5,6,7번 학생을 지목할때, 2번부터 7번 학생 으로 부름
    - 시작점과 끝점 2개의 점으로 접근할 데이터의 범위를 표현

    (1) 합이 M인 부분 연속 수열의 개수 구하기 -> O(N)
        - 과정
            1. 시작점(start)과 끝점(end)이 첫번째 인텍스(0)를 가리키도록 함
            2. 현재 부분 합이 M과 같다면, 카운트
            3. 현재 부분 합이 M보다 작다면, end를 1 증가
            4. 현재 부분 합이 M보다 크다면, start를 1 증가
            5. 모든 경우를 확인할 때까지 2-4번 반복

3. 구간 합
    - 구간 합 문제 : 연속적으로 나열된 N개의 수가 있을 떄, 특정 구간의 모든 수를 합한 값을 계산
        ex) {10, 20, 30, 40, 50}에서 2-5번째 수까지의 합 20 + 30 + 40 = 90
    - 시간 복잡도 : O(N + M)
    - 접두사 합(Prefix Sum) : 배열의 맨 앞부터 특정 위치까지의 합을 미리 구해 놓는 것
        1. N개의 수 위치 각각에 대하여 접두사 합을 계산하여 P에 저장
        2. 매 M개의 쿼리 정보를 확인할 때 구간 합은 P[right] - P[left - 1]